#!/usr/bin/env/python
#
# TOMMASO LAURENZI
#
# Eccolo! Come promesso il programmone per creare alberi filogenetici con il metodo Neighbour Joining per tutte le
# proteine che vuole!
#
#
# L'algoritmo principale e le funzioni per calcolare le matrici delle distanze si trovano nel modulo NJ. La funzione
# pairwise_alignment_initializer lì contenuta chiama a il modulo Align, che contiene l'algoritmo di
# allineamento dinamico, che riceve la matrice di inizializzazione da InitMatrix, che riceve a sua volta le matrici di
# sostituzione dal modulo SubMatrix (BLOSUM62 di default). Così ho dato ragione di esistere ai miei lavoretti precedenti
#
# Se NJ viene lanciato come script principale produce automaticamente 3 file pdf che contengono gli alberi delle
# proteine da lei indicate generati da matrici delle distanze differenti:
#   dal confronto del contenuto amminoacidico
#   dall'allineamento esatto di ogni coppia di sequenze (ci mette circa un minuto su un intel i7 con 6Gb di RAM)
#   dal confronto dei residui tra le sequenze allineate con Clustal-Omega
#
# In NJ la funzione principale è "tree_maker()", che riceve come input una matrice delle distanze rappresentata da un
# dizionario nella forma {('Nome_i','Nome_j'): 'Distanza'} e ritorna una stringa che rappresenta l'albero in formato
# Newick.
# Tale dizionario è creato dalle funzioni di calcolo della matrice delle distanze sopracitate, che ricevono come
# input, anch'esse, un dizionario nella forma {'Nome':'Sequenza'}
#
# Questo script serve appunto a scegliere il metodo di calcolo della matrice delle distanze, e creare il dizionario
# Nome: Sequenza da passare alle funzioni. L'output di queste funzioni viene quindi passato a tree_maker() per generare
# l'albero. Alla fine l'albero è salvato in un file di testo che viene prima letto e poi disegnato da biopython, e
# successivamente verrà richiesto di inserire il nome con cui si desidera salvare il dendrogramma in un file pdf.
# Non è necessario dichiarare l'estensione.
#
# Se si sceglie di utilizzare il confronto del contenuto amminoacidico o l'allineamento a coppie, verranno richiesti gli
# identificatori di UniProt. A partire da questi lo script recupererà dal server un file in formato FASTA (temporaneo) e
# leggerà le sequenze e i loro nomi per costruire il dizionario da passare alle funzioni di calcolo della matrice.
# Se invece si sceglie di costruire un albero a partire da un allineamento multiplo, verrà richiesto il nome del file
# di allienamento multiplo, che dovrà essere nella stessa cartella in cui vive il programma, che verrà letto per
# recuperare le informazioni necessarie da passare alla funzione.
# Ho lasciato nella cartella il file "msa.txt", che contiene l'allineamento di Clustal-O per le 5 proteine.
#
# All'interno di NJ ci sono anche tutti i commenti che spiegano l'algoritmo e dei blocchi cancellettati che se liberati
# mostrano il procedimento passo passo.
#
# I commenti sono in inglese, un po' per allenamento personale e un po' perchè mi obbliga a pensare a quello che scrivo
# e quindi a formalizzare con attenzione quello che sto facendo.
#
# Grazie per avermi fatto scoprire Python e il meraviglioso mondo della Bioinformatica!
#

from pyAlign_package import NJ
import Bio.Phylo
import matplotlib.pyplot as plt


def getseq(accession_number, erase=False):
    """
    Retrieves a sequence from its UniProt accession number, requires urllib and an internet connection!
    if called with erase = True it will delete the generated Fasta file.

    :param accession_number: Str accession number
    :param erase: Bool
    :return: Str sequence's readable name, Str sequence; if erase --> None
    """
    if not erase:
        import urllib.request as url
        address = 'http://www.uniprot.org/uniprot/{}.fasta'.format(accession_number)
        file, _ = url.urlretrieve(address, '{}.txt'.format(accession_number))
        with open(file) as seq_file:
            lines = seq_file.readlines()
            whitespace = lines[0].find(' ')
            name = lines[0][11:whitespace]  # o [2:whitespace] per leggere anche l'accession number
            seq = ''.join(lines[1:]).replace('\n', '')
        url.urlcleanup()
        return name, seq
    if erase:
        import os
        file = accession_number+'.txt'
        os.remove(file)
        return


def msa_parse(filename):
    """
    Parses a MSA file and returns a list of sequences' names and a list of sequences

    :param filename: Str the name of MSA file
    :return: List, List
    """
    with open(filename) as file:
        msa = file.readlines()
    taxa = []
    for line in msa:
        whitespace = line.find(' ')
        taxa.append(line[10:whitespace])  # o [:whitespace] per leggere anche l'accession number  e...
    IDs = list(set(taxa))
    IDs.remove('')

    sequences = []
    for ID in IDs:
        seq = ''
        for line in msa:
            line.replace(' ','')
            if ID in line:
                seq = seq + line[10+len(ID):len(line)].replace(' ','')  # ...togliere il 10
        sequences.append(seq)
    return IDs, sequences


data = input("Create a Distance Matrix from\n"
             "aminoacidic composition ['aa_comp']\n"
             "pairwise alignment ['pair']\n"
             "MSA file ['msa']\n"
             ": ")

if data in ('aa_comp', 'pair'):
    # create a dictionary {Taxa_Name: Sequence} from uniprot IDs
    # i.e.
    # P02758
    # P04119
    # P02754
    # P02756
    # P67976
    raw_sequences = {}
    while True:
        seq = input('Insert UniProt Identifier or [\'end\']: ')
        if seq in ('end'):
            print('Calculating Tree...')
            break
        else:
            taxa_name, sequence = getseq(seq)
            getseq(seq, erase=True)
            raw_sequences[taxa_name] = sequence
    if data == 'aa_comp':
        distance_matrix = NJ.aminoacidic_composition_initializer(raw_sequences)
    if data == 'pair':
        distance_matrix = NJ.pairwise_alignment_initializer(raw_sequences)

if data == 'msa':
    # Parse the MSA file and create a dictionary {Taxa_Name: Sequence}
    filename = input('Insert MSA filename in CWD (i.e. "msa.txt"): ')
    IDs, sequences = msa_parse(filename)
    msa_sequences = {}
    for ID, seq in zip(IDs, sequences):
        msa_sequences[ID] = seq
    distance_matrix = NJ.msa_distance_initializer(msa_sequences)
    print('Calculating Tree...')

TREE = NJ.tree_maker(distance_matrix)
print()
print(TREE)
print()
#filename = 'MyTree'
filename = input('Choose a file_name to save the tree: ') # greenpeace

with open(filename+'.dnd', 'x') as tree_txt:
    tree_txt.write(TREE)
tree = Bio.Phylo.read(filename+'.dnd', format='newick') # creates a tree object
Bio.Phylo.draw(tree, do_show=True) # draws it
#plt.savefig(filename+'.pdf')
